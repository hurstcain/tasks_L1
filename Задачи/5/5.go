package main

import (
	"context"
	"flag"
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func main() {
	// Количество секунд, по истечению которых программа должна будет завершить свою работу
	// Если при запуске программы флаг не указан, то значение по умолчанию - 3 секунды
	seconds := flag.Int("seconds", 3, "Number of seconds after which the program finishes its work")
	flag.Parse()

	// Канал, в который будут записываться данные
	ch := make(chan int, 10)

	// Группа горутин, завершения которых программа будет ожидать
	wg := sync.WaitGroup{}
	// Всего этих горутин две
	wg.Add(2)

	// Контекст, который автоматически отменяется по истечении времени ожидания (seconds секунд)
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(*seconds)*time.Second)
	defer cancel()

	// Горутина, которая записывает данные в канал и следит за тем, истекло ли время работы программы
	go func() {
		// По завершению работы горутины уменьшает количество работающих горутин на единицу
		defer wg.Done()
		for {
			select {
			// Когда время ожидания (seconds секунд) истекло, этот канал закрывается, и
			// данные из этого канала можно прочитать
			// Таким образом, когда время заканчивается, канал ch на чтение и запись данных закрывается,
			// и горутина заканчивает свою работу
			case <-ctx.Done():
				fmt.Printf("%d seconds have passed. Closing channel...\n", *seconds)
				close(ch)
				return
			// Если время еще не прошло, в канал записываются данные
			default:
				ch <- rand.Intn(100)
			}
		}
	}()

	// Горутина, которая читает данные из канала
	go func() {
		defer wg.Done()
		for {
			// Здесь происходит проверка на то, закрыт ли канал. Если канал открыт, то переменная ok равна true,
			// тогда данные из канала считываются. А если ok равна false, то это значит, что канал закрыт, тогда
			// горутина завершает свою работу
			if val, ok := <-ch; ok {
				fmt.Println(val)
			} else {
				return
			}
		}
	}()

	// Ожидает завершения работы всех горутин
	wg.Wait()

	fmt.Println("Program is finished")
}
