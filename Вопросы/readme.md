# Вопросы

### 1. Какой самый эффективный способ конкатенации строк?

Эффективно конкатенировать строки можно с помощью типа strings.Builder.
Чтобы реализация с помощью strings.Builder работала эффективнее, нужно перед объединением строк
выделить память с помощью метода Grow. Объединять можно строки, 
руны, байты, слайсы байтов с помощью методов WriteString,
WriteRune, WriteByte, Write. Вернуть получившуюся строку можно с помощью метода String.

Пример кода:
```go
s1 := "12345"
s2 := " 9882738"
var builder strings.Builder
builder.Grow(len(s1) + len(s2))
builder.WriteString(s1)
builder.WriteString(s2)
s := builder.String()
```

### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы - это набор описаний методов, которые должны быть у какого-либо другого типа. В Go, если структура содержит некоторый набор методов, 
который определяет некоторый интерфейс, то эта структура неявно реализует данный интерфейс. Структуры могут реализовывать несколько интерфейсов.  
Например, есть интерфейс Closer:
```go
type Closer interface {
    Close() error
}
```  
Структура, у которой есть метод с названием Close, который не принимает ни одного аргумента и который возвращает ошибку, будет реализовывать данный интерфейс.  

Также в Go можно передавать в функции различные объекты, реализующие конкретный интерфейс.  
Например, есть функция PrintString:
```go
func PrintString(s fmt.Stringer) {
    fmt.Println(s.String())
}
```
В качестве аргумента функция принимает объект, реализующий интерфейс fmt.Stringer. Таким образом, мы можем передавать в функцию 
объекты различных типов, но все они будут реализовывать интерфейс fmt.Stringer.

### 3. Чем отличаются RWMutex от Mutex?

Если Mutex блокирует операции и чтения, и записи, то RWMutex блокирует только операции записи.  
У RWMutex есть методы RLock и RUnlock, которые обеспечивают возможность параллельного выполнения операций чтения.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

У буферизированного канала есть буфер некоторого размера, то есть в буферизированный канал можно записать больше одного элемента. 
При этом функция, которая записывает данные в канал, не блокируется до тех пор, пока она не пытается записать данные в переполненный канал.
А при создании не буферизированного канала размер буфера не указывается. И когда функция записывает данные в не буферизированный канал, 
она блокируется до тех пор, пока другая горутина не прочитает данные из канала.

Создание буферизированного канала:  
```go
ch := make(chan int, 10)
```

Создание не буферизированного канала:
```go
ch := make(chan int)
```

### 5. Какой размер у структуры struct{}{}?

У пустой структуры размер 0 (это можно узнать с помощью функции unsafe.Sizeof()).

### 6. Есть ли в Go перегрузка методов или операторов?

Перегрузки методов и операторов в Go нет. 

### 7. В какой последовательности будут выведены элементы map[int]int?

Пример:
```go
m[0]=1
m[1]=124
m[2]=281
```

Тип данных map в Go является неупорядоченным. То есть элементы будут выведены в произвольном порядке.

### 8. В чем разница make и new?

Функция make может создавать слайсы, отображения и каналы. Она полностью инициализирует внутреннюю структуру данных типа
и возвращает его значение. А функция new создает неименованную переменную определенного типа (int, string, bool, []int и т.д.), инициализирует эту переменную нулевым значением и 
возвращает указатель на эту переменную.

### 9. Сколько существует способов задать переменную типа slice или map?

*slice*:
1) ``var a []int``
3) ``var a = []int{1, 2, 3}``
4) ``a := []int{1, 2, 3}``
5) ``a := make([]int, 3, 9)``
6) ``arr := [4]int{1, 2, 3, 4}; a := arr[2:]``

*map*:
1) ``var a map[string]int``
2) ``var a = map[string]int{}``
3) ``a := map[string]int{}``
4) ``a := make(map[string]int)``

### 10. Что выведет данная программа и почему?
```go
func update(p *int) {
    b := 2
    p = &b
}
func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```

Первый println выведет 1, второй также выведет 1.

В программе в функции main объявлены две переменные: переменная a типа int со значением 1 и 
указатель p типа *int на переменную a. В функцию update передается копия указателя p. Таким образом, 
если мы меняем значение указателя (то есть адрес переменной, на которую ссылается указатель) в функции update, 
то мы меняем копию p, которая передана в функцию, а не исходную переменную p. В итоге после завершения работы функции update 
p из main будет иметь то же значение, что и раньше.

### 11. Что выведет данная программа и почему?
```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```

Программа сначала выведет целые числа от 0 до 4 в том порядке, в каком отработали горутины, а затем выведет ошибку о том, что произошел дедлок. 

Дедлок происходит из-за того, что в функцию горутин передается не ссылка на экземпляр структуры sync.WaitGroup, а копия экземпляра. 
Из-за этого счетчик горутин в оригинальной структуре wg не уменьшается, когда горутины заканчивают свою работу. 
То есть в горутинах метод Done() уменьшает счетчик для каждой копии переменной wg, но не для оригинальной переменной, которая объявлена в main. 
И после того, как горутины отработали, значение счетчика в оригинальной переменной wg остается прежним. И уменьшить счетчик больше нет возможности. 
Из-за этого программе суждено остановить свое выполнение на строке wg.Wait() и вечно ожидать остановки горутин, которые уже завершили свою работу.


### 12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```

Программа выведет 0.

В функции main создается переменная n, которой присваивается значение 0. 
В блоке if также создается переменная с именем n, которой присваивается значение 1. 
Эта переменная не является переменной n из функции main. n = 1 это переменная блока if, которая видна только в этом блоке. 
Также эта переменная перекрывает переменную n из функции main. Что означает, 
что в блоке if n из main не видна и использоваться не может.
Таким образом, все изменения, которые происходят в блоке if с переменной n 
относятся только к блоку if. Переменная n из функции main изменена не будет.


### 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}
func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```

Программа выведет ``[100 1 2 3 4 5]``.

В функции main создается слайс a, который имеет длину и емкость равные 5.
Слайс передается в функцию someAction. Данная функция должна менять 
первый элемент слайса на число 100 и добавлять в слайс новый элемент b.  
При передаче в функцию слайса также передаются ссылки на значения элементов массива, на который ссылается данный слайс. 
Таким образом, меняя элементы в функции в копии слайса, также меняются значения элементов оригинального слайса. 
Но, передавая слайс в функцию не по ссылке, мы не можем изменить длину или емкость слайса.  
Таким образом, изменение первого элемента слайса в функции someAction отразится и на оригинальном слайсе, 
но при добавлении нового элемента в слайс, создается новый слайс v с длиной 6 и увеличенной емкостью, ссылающийся 
на новый массив в памяти. Теперь слайс v принадлежит функции someAction. 
А слайс из функции main остается все с теми же емкостью 5 и размером 5, но с измененным первым элементом.

### 14. Что выведет данная программа и почему?
```go
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```

Первый Print выведет ``[b b a]``.  
Второй Print выведет ``[a a]``.

В программе создается слайс slice из двух элементов. 
Затем этот слайс передается в анонимную функцию, которая тут же вызывается.
В анонимной функции все манипуляции со слайсом будут относиться именно к внутренней переменной slice, 
которая является копией внешней переменной slice, объявленной внутри main.  
Когда мы передаем слайс в функцию, вместе со слайсом передаются ссылки на значения переменных массива, 
на который ссылается слайс. Таким образом, если изменять элементы массива внутри функции, 
значения будут меняться и в оригинальном слайсе. Но при передаче копии слайса в функцию не передаются 
ссылки на длину и емкость слайса. То есть структуру слайса таким образом изменить невозможно, только значения элементов.  
Слайс из функции main имеет длину и емкость равные двум.
Когда внутри анонимной функции мы добавляем новый элемент в слайс,
создается новый слайс длиной 3 и увеличенной емкостью, который помещается в другое место в памяти.
Таким образом, слайс внутри анонимной функции начинает ссылаться на другой массив в памяти. 
И, когда элементы этого слайса будут изменяться, элементы слайса из main будут иметь прежние значения.